import tensorflow as tf
from tensorflow.keras import layers
from sklearn.model_selection import train_test_split
import pandas as pd

# Assuming the dataset has been defined and preprocessed (data, df_age, etc.)

# Step 1: Preprocess the Data (as done previously)
df_no_age = data.copy()  # Use your original dataset with necessary preprocessing
df_no_age.fillna(0, inplace=True)

PRTCP_IDs = df_no_age['PRTCP_ID']
y = df_no_age['STP_DFR_TRGT']
X = df_no_age.drop(columns=['STP_DFR_TRGT', 'PRTCP_ID'])
X = pd.get_dummies(X)

# Split data into train and test sets
X_train, X_test, y_train, y_test, PRTCP_ID_train, PRTCP_ID_test = train_test_split(X, y, PRTCP_IDs, test_size=0.2, random_state=42)

# Prepare the test DataFrame with predictions
df_test = X_test.copy()
df_test['PRTCP_ID'] = PRTCP_ID_test.reset_index(drop=True)

# Step 5: Adversarial Debiasing
# Build the adversary model to predict AGE_GRP_CD
adversary = tf.keras.Sequential([
    layers.Input(shape=(1,)),  # Input shape for the model's prediction
    layers.Dense(10, activation='relu'),
    layers.Dense(1, activation='sigmoid')  # Predicting age group (binary classification)
])

# Compile the adversary
adversary.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# Get predictions from the main model (make sure the model is trained before this)
y_pred = model.predict(X_test)  # y_pred should have shape (num_samples, 1)

# Reshape y_pred to ensure it's 2D
y_pred = y_pred.reshape(-1, 1)  # Reshape to (num_samples, 1)

# Check df_age structure before merging
print("df_age structure:\n", df_age.head())  # Print first few rows of df_age

# Merge to get AGE_GRP_CD into df_test
df_test = pd.merge(df_test, df_age, on='PRTCP_ID', how='left')

# Ensure AGE_GRP_CD is present and matches the number of samples
if 'AGE_GRP_CD' not in df_test.columns:
    raise ValueError("AGE_GRP_CD column is missing in df_test after merging.")
else:
    print("AGE_GRP_CD successfully added to df_test.")

# Train the adversary using the main model's predictions and the true AGE_GRP_CD
adversary.fit(y_pred, df_test['AGE_GRP_CD'].values, epochs=10, batch_size=32)

# Step 6: Adjust Main Model to Fool Adversary
for _ in range(5):
    model.fit(X_train, y_train)  # Retrain the main model

    # Get updated predictions from the main model
    y_pred = model.predict(X_test).reshape(-1, 1)  # Reshape to (num_samples, 1)

    # Continue training the adversary with new predictions
    adversary.fit(y_pred, df_test['AGE_GRP_CD'].values, epochs=5, batch_size=32)

# Step 7: Evaluate Bias After Debiasing
y_pred_debiased = model.predict(X_test).reshape(-1, 1)  # Reshape to (num_samples, 1)
df_test['pred_debiased'] = y_pred_debiased

# Recalculate bias metrics after debiasing
dppl_debiased = calculate_dppl(age_group=1, pred_col='pred_debiased')  # Adjust age_group as needed
dpl_debiased = calculate_dpl(age_group=0, target_col='STP_DFR_TRGT')

dppl_dpl_debiased = dppl_debiased - dpl_debiased
print(f'DPPL-DPL for age group after debiasing: {dppl_dpl_debiased}')

# Ensure that DPPL-DPL is between -0.5 and 0.5
assert -0.5 < dppl_dpl_debiased < 0.5, "Bias is still present!"